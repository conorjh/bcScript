#include "types.h"
#include "util.h"
#include "error.h"
#include "tree.hh"
#include <stack>
#include <map>
#include <vector>

const bool bcParser_CheckEmptyInput = false;

class bcParser
{

public:
	bcParser();
	bcParser(vector<bcToken>*);
	int Init();		
	int Load(vector<bcToken>*);

	//Token input
	bcToken* ReadToken();
	bcToken* ReadToken(bcTokenType);
	bcToken* CurrentToken();
	bcToken* NextToken();
	bcToken* PreviousToken();
	void ClearPNBuff();
	
	//Main Parsing methods
	int Parse();
	int Parse(vector<bcToken>* );		
	int PreParse();	
	int ParseStatement();
	int ParseBlock();
	int ParseBlockNoDec();
	int ParseAssignment();
	int ParseFuncCall();
	int ParseDec();
	int ParseDecFunc();
	int ParseDecFunc_Type();
	int ParseDecFunc_Ident();
	int ParseIf();
	int ParseWhile();
	int ParseBreak();
	int ParseReturn();
	int ParseContinue();		
	int ParseParamList();
	int ParseDecParamList();	
	int ParseDecInParam();	
	int ParseFExp();
	bcToken ParseExp();
	bcToken ParseSubExp();
	bcToken ParseTerm();
	bcToken ParseFactor();

	//data comparison
	bool CheckOperandTypes(bcToken,bcToken,bcTokenType);
	bool CheckOperandInt(bcToken,bcTokenType);
	bool CheckOperandFloat(bcToken,bcTokenType);
	bool CheckOperandString(bcToken,bcTokenType);
	bool CheckOperandBool(bcToken,bcTokenType);
	bool CheckOperandObject(bcToken,bcTokenType);
	bool CheckOperandVar(bcToken,bcTokenType);
	bool CheckOperandFunction(bcToken,bcTokenType);
	bool CompareFuncSigs(string, vector<map<string,bcSymbol>::iterator>);
	string GetTag(bcSymbol*);

	//Symbol table
	map<string,bcSymbol> symtab;
	bcSymbolType ToSymbolType(bcTokenType);
	map<string,bcSymbol>::iterator AddSymbol(bcSymbol);
	map<string,bcSymbol>::iterator AddSymbol(bcSymbol,string);
	map<string,bcSymbol>::iterator AddSymbol(string,bcSymbolType,string,map<string,bcSymbol>::iterator);
	bcSymbol* GetSymbol(string ident);
	map<string,bcSymbol>::iterator GetSymbolIt(string ident); //iterator from symtab key
	map<string,bcSymbol>::iterator GetSymbolIt(bcToken); //iterator from bcToken
	string SigToIdent(string,vector<map<string,bcSymbol>::iterator>);	//generate a funcsig key from symbolname and vector of symtab iterators
	bool IsScopeValid(bcSymbol*);						//checks a symbols scope is valid in the current scope

	//Error	
	bcErrorCode errorcode;
	bool IsError();
	bcErrorCode GetError();
	int GetErrorLine();
	int GetErrorCol();
	void SetError(bcErrorCode,int line,int col);
	void ResetError();
	bool error;
	int error_line;
	int error_col;
	int whilecount,funccount;
	
	//data
	tree<bcParseNode> ptree;										//the AST we create 
	tree<bcParseNode>::iterator pindex;								//Current node we are working on
	map<string,vector<map<string,bcSymbol>::iterator>> stackframes;	//Stores stackframes for function decs and global
	bcParseNode pnbuff;												//current node we are constructing
	map<string,bcSymbol>::iterator scope;							//current scope as a symbol
	stack<map<string,bcSymbol>::iterator> openscopes;				//list of opened scopes
	vector<map<string,bcSymbol>::iterator>* stackframebuff;			//current functions stackframe	(params, locals, return addy)
	map<string,vector<map<string,bcSymbol>::iterator>> funcsigs;	//iternal symbol name, vector of symtab iterators
	vector<map<string,bcSymbol>::iterator> sigbuff,callsigbuff;		//buffers to store params from ParseParamList/ParseDecParamList, and check in CallFunc/DecFunc
	vector<bcSymbol> parambuff;										//parameter symbols generated by function dec (parsedecparamlist())				
	int parencount;
	int bracecount;
	int index;
	bool safe;
	bool nodec;//if true, declarations are invalid (inside if/while blocks for instance)
	vector<bcToken>* in;
};